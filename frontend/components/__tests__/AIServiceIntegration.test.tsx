/**\n * @file AIServiceIntegration.test.tsx\n * @description Integration tests for the enhanced AI service with streaming support\n * @version 1.0.0\n * @since 0.6.0\n */\n\nimport React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport AITestInterface from '../AITestInterface';\nimport { aiService } from '../../services/aiService';\nimport * as providerService from '../../services/providerService';\nimport * as authService from '../../services/authService';\n\n// Mock dependencies\njest.mock('../../services/aiService');\njest.mock('../../services/providerService');\njest.mock('../../services/authService');\njest.mock('../../config/modelCapabilities');\n\nconst mockAiService = aiService as jest.Mocked<typeof aiService>;\nconst mockProviderService = providerService as jest.Mocked<typeof providerService>;\nconst mockAuthService = authService.default as jest.Mocked<typeof authService.default>;\n\ndescribe('AI Service Integration', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    \n    // Mock provider service responses\n    mockProviderService.getProviderConfigurations.mockResolvedValue([\n      {\n        provider: 'google',\n        hasApiKey: true,\n        isConfigured: true,\n        config: {\n          provider: 'google',\n          name: 'Google Gemini',\n          description: 'Google\\'s multimodal AI models',\n          models: [\n            {\n              id: 'gemini-2.5-flash',\n              name: 'Gemini 2.5 Flash',\n              provider: 'google',\n              description: 'Fast and efficient model',\n              contextLength: 1000000,\n              supportedParameters: ['temperature', 'maxTokens', 'topK', 'topP'],\n              constraints: {\n                temperature: { min: 0.0, max: 2.0, step: 0.1, default: 1.0 },\n                maxTokens: { min: 1, max: 8192, step: 1, default: 1024 }\n              }\n            }\n          ],\n          defaultParameters: {\n            temperature: 1.0,\n            maxTokens: 1024\n          },\n          supportedFeatures: ['text', 'multimodal'],\n          requiresApiKey: true\n        }\n      }\n    ]);\n    \n    mockProviderService.getStoredProviders.mockResolvedValue({\n      success: true,\n      providers: ['google']\n    });\n    \n    // Mock auth service\n    mockAuthService.authenticatedFetch.mockResolvedValue({\n      ok: true,\n      json: async () => ({\n        success: true,\n        data: {\n          response: 'Test AI response'\n        }\n      })\n    } as Response);\n  });\n\n  describe('Non-streaming Generation', () => {\n    it('should generate AI response successfully', async () => {\n      mockAiService.generateResponse.mockResolvedValue({\n        success: true,\n        response: 'Test AI response',\n        metadata: {\n          provider: 'google',\n          model: 'gemini-2.5-flash',\n          latency: 1500,\n          tokensUsed: 50\n        }\n      });\n\n      render(<AITestInterface />);\n      \n      // Enter test prompt\n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Test prompt' } });\n      \n      // Disable streaming\n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      fireEvent.click(streamingToggle);\n      \n      // Click test button\n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      // Wait for response\n      await waitFor(() => {\n        expect(screen.getByText('Test AI response')).toBeInTheDocument();\n      });\n      \n      // Verify service was called correctly\n      expect(mockAiService.generateResponse).toHaveBeenCalledWith(\n        'google',\n        'gemini-2.5-flash',\n        'Test prompt',\n        expect.objectContaining({\n          stream: false\n        })\n      );\n    });\n\n    it('should handle generation errors gracefully', async () => {\n      mockAiService.generateResponse.mockRejectedValue(new Error('API Error'));\n\n      render(<AITestInterface />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Test prompt' } });\n      \n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      fireEvent.click(streamingToggle);\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText('Error')).toBeInTheDocument();\n        expect(screen.getByText('API Error')).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Streaming Generation', () => {\n    it('should handle streaming responses', async () => {\n      const mockStreamCallback = jest.fn();\n      \n      mockAiService.streamResponse.mockImplementation(async (provider, model, prompt, options, config) => {\n        // Simulate streaming chunks\n        const chunks = [\n          { content: 'Hello ', finished: false },\n          { content: 'world!', finished: true, metadata: { tokensUsed: 3 } }\n        ];\n        \n        for (const chunk of chunks) {\n          config.onChunk(chunk);\n          await new Promise(resolve => setTimeout(resolve, 50));\n        }\n        \n        return 'Hello world!';\n      });\n\n      render(<AITestInterface />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Test prompt' } });\n      \n      // Ensure streaming is enabled (default)\n      expect(screen.getByLabelText('Enable Streaming Response')).toBeChecked();\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      // Wait for streaming to complete\n      await waitFor(() => {\n        expect(screen.getByText('Hello world!')).toBeInTheDocument();\n      }, { timeout: 3000 });\n      \n      expect(mockAiService.streamResponse).toHaveBeenCalled();\n    });\n\n    it('should allow cancellation of streaming requests', async () => {\n      let cancelled = false;\n      \n      mockAiService.streamResponse.mockImplementation(async (provider, model, prompt, options, config) => {\n        return new Promise((resolve, reject) => {\n          const interval = setInterval(() => {\n            if (config.signal?.aborted) {\n              cancelled = true;\n              clearInterval(interval);\n              reject(new Error('Request cancelled'));\n            }\n          }, 100);\n          \n          setTimeout(() => {\n            clearInterval(interval);\n            resolve('Complete response');\n          }, 2000);\n        });\n      });\n\n      render(<AITestInterface />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Long test prompt' } });\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      // Wait for generation to start\n      await waitFor(() => {\n        expect(screen.getByText('Generating...')).toBeInTheDocument();\n      });\n      \n      // Click stop button\n      const stopButton = screen.getByText('Stop');\n      fireEvent.click(stopButton);\n      \n      // Verify cancellation\n      await waitFor(() => {\n        expect(cancelled).toBe(true);\n      });\n    });\n  });\n\n  describe('Provider Integration', () => {\n    it('should integrate with ProviderSwitcher', async () => {\n      render(<AITestInterface />);\n      \n      // ProviderSwitcher should be rendered\n      expect(screen.getByText('AI Provider Configuration')).toBeInTheDocument();\n      \n      // Should show current provider\n      await waitFor(() => {\n        expect(screen.getByDisplayValue('google')).toBeInTheDocument();\n      });\n    });\n\n    it('should update generation when provider changes', async () => {\n      mockProviderService.getProviderConfigurations.mockResolvedValue([\n        {\n          provider: 'openai',\n          hasApiKey: true,\n          isConfigured: true,\n          config: {\n            provider: 'openai',\n            name: 'OpenAI',\n            description: 'OpenAI GPT models',\n            models: [\n              {\n                id: 'gpt-4o',\n                name: 'GPT-4 Omni',\n                provider: 'openai',\n                description: 'Most capable GPT-4 model',\n                contextLength: 128000,\n                supportedParameters: ['temperature', 'maxTokens', 'top_p'],\n                constraints: {\n                  temperature: { min: 0.0, max: 2.0, step: 0.1, default: 1.0 },\n                  maxTokens: { min: 1, max: 4096, step: 1, default: 1024 }\n                }\n              }\n            ],\n            defaultParameters: {\n              temperature: 1.0,\n              maxTokens: 1024\n            },\n            supportedFeatures: ['text', 'multimodal'],\n            requiresApiKey: true\n          }\n        }\n      ]);\n\n      mockAiService.generateResponse.mockResolvedValue({\n        success: true,\n        response: 'OpenAI response',\n        metadata: {\n          provider: 'openai',\n          model: 'gpt-4o'\n        }\n      });\n\n      render(<AITestInterface />);\n      \n      // Change provider (this would require more complex mocking of ProviderSwitcher)\n      // For now, just verify that the service would be called with the right parameters\n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Test with different provider' } });\n      \n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      fireEvent.click(streamingToggle);\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      await waitFor(() => {\n        expect(mockAiService.generateResponse).toHaveBeenCalled();\n      });\n    });\n  });\n\n  describe('Parameter Handling', () => {\n    it('should include system message in requests', async () => {\n      mockAiService.generateResponse.mockResolvedValue({\n        success: true,\n        response: 'Response with system message',\n        metadata: { provider: 'google', model: 'gemini-2.5-flash' }\n      });\n\n      render(<AITestInterface showAdvanced={true} />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Test prompt' } });\n      \n      const systemInput = screen.getByPlaceholderText('Enter system instructions...');\n      fireEvent.change(systemInput, { target: { value: 'You are a helpful assistant.' } });\n      \n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      fireEvent.click(streamingToggle);\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      await waitFor(() => {\n        expect(mockAiService.generateResponse).toHaveBeenCalledWith(\n          'google',\n          'gemini-2.5-flash',\n          'Test prompt',\n          expect.objectContaining({\n            systemMessage: 'You are a helpful assistant.',\n            stream: false\n          })\n        );\n      });\n    });\n\n    it('should include provider-specific parameters', async () => {\n      mockAiService.generateResponse.mockResolvedValue({\n        success: true,\n        response: 'Response with custom parameters',\n        metadata: { provider: 'google', model: 'gemini-2.5-flash' }\n      });\n\n      const initialConfig = {\n        provider: 'google' as const,\n        apiKey: '',\n        model: 'gemini-2.5-flash',\n        parameters: {\n          temperature: 0.7,\n          maxTokens: 2048,\n          topK: 40\n        },\n        baseUrl: ''\n      };\n\n      render(<AITestInterface initialConfig={initialConfig} />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Test with parameters' } });\n      \n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      fireEvent.click(streamingToggle);\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      await waitFor(() => {\n        expect(mockAiService.generateResponse).toHaveBeenCalledWith(\n          'google',\n          'gemini-2.5-flash',\n          'Test with parameters',\n          expect.objectContaining({\n            temperature: 0.7,\n            maxTokens: 2048,\n            topK: 40\n          })\n        );\n      });\n    });\n  });\n\n  describe('Test History', () => {\n    it('should track successful tests in history', async () => {\n      mockAiService.generateResponse.mockResolvedValue({\n        success: true,\n        response: 'Historical response',\n        metadata: {\n          provider: 'google',\n          model: 'gemini-2.5-flash',\n          latency: 1200\n        }\n      });\n\n      render(<AITestInterface />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Historical test' } });\n      \n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      fireEvent.click(streamingToggle);\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText('Historical response')).toBeInTheDocument();\n      });\n      \n      // Check that history section appears\n      expect(screen.getByText('Recent Tests')).toBeInTheDocument();\n      expect(screen.getByText('Historical test')).toBeInTheDocument();\n      expect(screen.getByText(/google.*gemini-2.5-flash.*1200ms/)).toBeInTheDocument();\n    });\n\n    it('should track failed tests in history', async () => {\n      mockAiService.generateResponse.mockRejectedValue(new Error('Test failure'));\n\n      render(<AITestInterface />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Failing test' } });\n      \n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      fireEvent.click(streamingToggle);\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      await waitFor(() => {\n        expect(screen.getByText('Test failure')).toBeInTheDocument();\n      });\n      \n      // Check that failed test appears in history with error styling\n      expect(screen.getByText('Recent Tests')).toBeInTheDocument();\n      expect(screen.getByText('Failing test')).toBeInTheDocument();\n    });\n  });\n\n  describe('UI Controls', () => {\n    it('should disable controls during generation', async () => {\n      mockAiService.generateResponse.mockImplementation(() => \n        new Promise(resolve => setTimeout(() => resolve({\n          success: true,\n          response: 'Delayed response',\n          metadata: { provider: 'google', model: 'gemini-2.5-flash' }\n        }), 1000))\n      );\n\n      render(<AITestInterface />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      const testButton = screen.getByText('Test Prompt');\n      \n      fireEvent.change(promptInput, { target: { value: 'Test prompt' } });\n      fireEvent.click(streamingToggle); // Disable streaming for this test\n      fireEvent.click(testButton);\n      \n      // Controls should be disabled during generation\n      expect(promptInput).toBeDisabled();\n      expect(streamingToggle).toBeDisabled();\n      expect(screen.getByText('Generating...')).toBeInTheDocument();\n      \n      // Wait for completion\n      await waitFor(() => {\n        expect(screen.getByText('Delayed response')).toBeInTheDocument();\n      }, { timeout: 2000 });\n      \n      // Controls should be re-enabled\n      expect(promptInput).not.toBeDisabled();\n      expect(streamingToggle).not.toBeDisabled();\n    });\n\n    it('should show retry button after errors', async () => {\n      mockAiService.generateResponse\n        .mockRejectedValueOnce(new Error('First failure'))\n        .mockResolvedValueOnce({\n          success: true,\n          response: 'Retry success',\n          metadata: { provider: 'google', model: 'gemini-2.5-flash' }\n        });\n\n      render(<AITestInterface />);\n      \n      const promptInput = screen.getByPlaceholderText('Enter your test prompt here...');\n      fireEvent.change(promptInput, { target: { value: 'Retry test' } });\n      \n      const streamingToggle = screen.getByLabelText('Enable Streaming Response');\n      fireEvent.click(streamingToggle);\n      \n      const testButton = screen.getByText('Test Prompt');\n      fireEvent.click(testButton);\n      \n      // Wait for error\n      await waitFor(() => {\n        expect(screen.getByText('First failure')).toBeInTheDocument();\n      });\n      \n      // Retry button should appear\n      const retryButton = screen.getByText('Retry');\n      expect(retryButton).toBeInTheDocument();\n      \n      // Click retry\n      fireEvent.click(retryButton);\n      \n      // Wait for success\n      await waitFor(() => {\n        expect(screen.getByText('Retry success')).toBeInTheDocument();\n      });\n    });\n  });\n});