/**
 * @file promptApiService.ts
 * @description This service module handles all CRUD (Create, Read, Update, Delete) operations
 * for SFL prompts by communicating with the backend API.
 *
 * @requires ../types
 */

import { PromptSFL } from '../types';
import authService from './authService';

/**
 * @constant {string} API_BASE_URL - The base URL for the prompt-related API endpoints.
 * It's a relative URL to leverage the Vite proxy during development.
 * @private
 */
const API_BASE_URL = '/api';

/**
 * Fetches all SFL prompts from the backend API.
 *
 * @returns {Promise<PromptSFL[]>} A promise that resolves to an array of all prompts.
 * @throws {Error} Throws an error if the network request fails or the server returns a non-ok response.
 *
 * @example
 * async function loadPrompts() {
 *   try {
 *     const prompts = await getPrompts();
 *     setPrompts(prompts);
 *   } catch (error) {
 *     console.error(error.message);
 *   }
 * }
 */
export const getPrompts = async (): Promise<PromptSFL[]> => {
  const response = await authService.authenticatedFetch(`${API_BASE_URL}/prompts`);
  if (!response.ok) {
    throw new Error('Failed to fetch prompts');
  }
  return response.json();
};

/**
 * Saves a new prompt or updates an existing one on the backend.
 * It intelligently determines whether to use a POST (create) or PUT (update) request
 * based on the presence of an `id` property in the provided prompt object.
 *
 * @param {Omit<PromptSFL, 'id' | 'createdAt' | 'updatedAt'> | PromptSFL} prompt - The prompt object to save.
 * If it has an `id`, it will be an update; otherwise, it's a creation.
 * @returns {Promise<PromptSFL>} A promise that resolves to the saved prompt object, including any fields
 * generated by the backend (like `id`, `createdAt`, `updatedAt`).
 * @throws {Error} Throws an error if the network request fails or the API returns an error message.
 *
 * @example
 * // To create a new prompt:
 * const newPrompt = { title: "New", promptText: "..." };
 * const savedPrompt = await savePrompt(newPrompt);
 *
 * // To update an existing prompt:
 * const updatedPrompt = { ...existingPrompt, title: "Updated Title" };
 * const result = await savePrompt(updatedPrompt);
 */
export const savePrompt = async (prompt: Omit<PromptSFL, 'id' | 'createdAt' | 'updatedAt'> | PromptSFL): Promise<PromptSFL> => {
  const isEditing = 'id' in prompt;
  const url = isEditing ? `${API_BASE_URL}/prompts/${prompt.id}` : `${API_BASE_URL}/prompts`;
  const method = isEditing ? 'PUT' : 'POST';

  const response = await fetch(url, {
    method,
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(prompt),
  });

  if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.message || `Failed to ${isEditing ? 'update' : 'create'} prompt`);
  }
  return response.json();
};

/**
 * Deletes a prompt from the backend using its unique ID.
 *
 * @param {string} id - The ID of the prompt to be deleted.
 * @returns {Promise<void>} A promise that resolves when the deletion is successful.
 * @throws {Error} Throws an error if the network request fails or the server indicates the deletion was unsuccessful.
 *
 * @example
 * try {
 *   await deletePrompt('some-prompt-id');
 *   // Remove the prompt from the local state
 * } catch (error) {
 *   console.error(error.message);
 * }
 */
export const deletePrompt = async (id: string): Promise<void> => {
  const response = await fetch(`${API_BASE_URL}/prompts/${id}`, {
    method: 'DELETE',
  });

  // A 204 No Content response is also a success case for DELETE.
  if (!response.ok && response.status !== 204) {
    throw new Error('Failed to delete prompt');
  }
};