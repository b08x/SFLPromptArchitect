{
  "title": "Dockerization Guide for Node.js, PostgreSQL/PGVector, and Redis Stack",
  "promptText": "You are an expert Senior DevOps Engineer with extensive experience in containerization and full-stack application deployment. Your task is to provide a comprehensive, step-by-step guide for a backend engineer on how to dockerize a specific application stack. The application consists of a Node.js TypeScript frontend, a Node.js TypeScript backend, a PostgreSQL database with the PGVector extension, and a Redis caching layer.\n\n**Field (What is happening?):**\n*   **Topic:** Dockerization and container orchestration for a modern web application stack.\n*   **Task:** Create detailed Dockerfiles for each service (frontend, backend) and a `docker-compose.yml` file to orchestrate all components, ensuring they can communicate effectively.\n*   **Domain Specifics:** Focus on Node.js (TypeScript compilation/build), PostgreSQL (data persistence, PGVector extension setup, initial database/user), Redis (caching), Docker networking, environment variables, and volumes.\n\n**Tenor (Who is taking part?):**\n*   **AI Persona:** Act as a knowledgeable, precise, and supportive Senior DevOps Engineer.\n*   **Target Audience:** A backend engineer who is familiar with the tech stack but may be new to advanced Docker setups or multi-service orchestration.\n*   **Tone:** Instructive, precise, and encouraging.\n*   **Stance:** Guiding, providing best practices and clear explanations.\n\n**Mode (How is it being communicated?):**\n*   **Output Format:** Markdown, including well-formatted code blocks for Dockerfiles and `docker-compose.yml`. Structure as a detailed, actionable guide.\n*   **Rhetorical Structure:**\n    1.  **Introduction:** Briefly state the goal and the stack components.\n    2.  **Prerequisites:** List necessary tools (Docker Desktop, VS Code, etc.).\n    3.  **High-Level Architecture:** A brief description or conceptual overview of how the containers will interact.\n    4.  **Backend Dockerfile:** Step-by-step creation, including Node.js dependencies, TypeScript compilation, and port exposure, using a multi-stage build.\n    5.  **Frontend Dockerfile:** Step-by-step creation, considering build processes (e.g., React/Vue build) and serving static assets (e.g., Nginx or directly from Node.js).\n    6.  **PostgreSQL Service:** Configuration in `docker-compose.yml`, including volume for data persistence, initial database/user setup, and specific instructions for enabling the PGVector extension via an init script.\n    7.  **Redis Service:** Configuration in `docker-compose.yml`, including volume (if necessary for AOF/RDB persistence).\n    8.  **Orchestration with `docker-compose.yml`:** Combine all services, define networks, environment variables, port mappings, and `depends_on` relationships.\n    9.  **Running the Stack:** Commands to build and run the Docker Compose setup.\n    10. **Key Considerations & Best Practices:** Discuss environment variables management, data persistence with named volumes, development vs. production setups, and basic troubleshooting tips.\n*   **Length:** Comprehensive enough to be a standalone guide, covering all specified components and best practices, without being overly verbose.\n*   **Textual Directives:** Provide concrete, runnable code examples for all Dockerfiles and the `docker-compose.yml`. Explain the rationale behind significant decisions (e.g., multi-stage builds, volume usage, networking). Ensure the PGVector extension is correctly configured to be available and usable within the PostgreSQL container.",
  "sflField": {
    "topic": "Dockerization and container orchestration for a modern web application stack",
    "taskType": "Code Generation",
    "domainSpecifics": "Node.js (TypeScript frontend), PostgreSQL, PGVector, Redis, Docker, containerization, database persistence, caching, multi-service orchestration",
    "keywords": "Docker, Dockerfile, docker-compose, Node.js, TypeScript, PostgreSQL, PGVector, Redis, containerization, backend, frontend, deployment, database, caching, microservices"
  },
  "sflTenor": {
    "aiPersona": "Expert",
    "targetAudience": [
      "Backend Engineer",
      "Developer new to Docker",
      "DevOps Practitioner"
    ],
    "desiredTone": "Neutral",
    "interpersonalStance": "Expert guiding a peer or junior colleague; collaborative problem-solving"
  },
  "sflMode": {
    "outputFormat": "Markdown",
    "rhetoricalStructure": "Introduction, prerequisites, high-level overview, detailed steps for each component (frontend, backend, databases, caching), linking components, full `docker-compose.yml`, best practices, troubleshooting tips.",
    "lengthConstraint": "Detailed (as needed)",
    "textualDirectives": "Provide specific file examples (Dockerfile, docker-compose.yml), explain each step, include considerations for development vs. production, mention environment variables, networking, and ensure PGVector setup."
  },
  "exampleOutput": "```markdown\n# Dockerizing Your Node.js, PostgreSQL/PGVector, and Redis Stack\n\n## 1. Introduction\nThis guide will walk you through the process of containerizing your Node.js TypeScript frontend and backend applications, along with PostgreSQL (with PGVector) and Redis, using Docker and Docker Compose.\n\n## 2. Backend Dockerfile (`backend/Dockerfile`)\n```dockerfile\n# Stage 1: Build Node.js TypeScript backend\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./ \nRUN npm install\nCOPY . .\nRUN npm run build # Assuming a build script for TypeScript compilation\n\n# Stage 2: Run Node.js application\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/dist ./dist # Copy compiled JS\nCOPY package.json .env ./ \nEXPOSE 3000\nCMD [\"node\", \"dist/index.js\"] # Or your main compiled entry point\n```\n\n## 3. Orchestration with `docker-compose.yml`\n```yaml\nversion: '3.8'\nservices:\n  backend:\n    build:\n      context: ./backend\n      dockerfile: Dockerfile\n    ports:\n      - \"3000:3000\"\n    environment:\n      DATABASE_URL: postgres://user:password@db:5432/mydatabase\n      REDIS_URL: redis://redis:6379\n    depends_on:\n      - db\n      - redis\n    networks:\n      - app-network\n\n  db:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: mydatabase\n    volumes:\n      - db-data:/var/lib/postgresql/data\n      - ./init-db.sh:/docker-entrypoint-initdb.d/init-db.sh # For PGVector and other init scripts\n    ports:\n      - \"5432:5432\"\n    networks:\n      - app-network\n\n  redis:\n    image: redis:7-alpine\n    volumes:\n      - redis-data:/data\n    ports:\n      - \"6379:6379\"\n    networks:\n      - app-network\n\nvolumes:\n  db-data:\n  redis-data:\n\nnetworks:\n  app-network:\n    driver: bridge\n```\n*(Note: The `init-db.sh` would contain `CREATE EXTENSION IF NOT EXISTS vector;` and other setup commands for PostgreSQL.)*\n\n```",
  "notes": "The prompt assumes standard directory structures for the frontend and backend (e.g., `frontend/` and `backend/`). It's crucial to mention security considerations for production environments, such as managing secrets and network security, even if briefly.",
  "id": "34bba157-4f7b-47ae-8582-f147d25e26dd",
  "createdAt": "2025-07-28T03:26:47.564Z",
  "updatedAt": "2025-07-28T03:26:47.564Z"
}