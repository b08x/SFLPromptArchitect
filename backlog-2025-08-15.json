{
  "project": "SFL Prompt Studio",
  "version": "2.1.0",
  "backlog": [
    {
      "id": "ASYNC-01",
      "title": "Integrate Redis and BullMQ for Backend Job Queuing",
      "epic": "Asynchronous Workflow Execution",
      "story": "As a backend developer, I want to integrate Redis and BullMQ into the backend service to manage long-running workflow executions as background jobs, so that the API can respond instantly and the system is more resilient.",
      "acceptanceCriteria": [
        "Redis is added as a service in the `docker-compose.yml` file.",
        "BullMQ is added as a dependency to the backend `package.json`.",
        "A new `JobService` is created to handle adding jobs to a queue and processing them.",
        "The `workflowExecutionController` is updated to create a job when a workflow is executed, instead of running it synchronously.",
        "Environment variables for Redis connection are added to `.env.example`."
      ],
      "system_prompt": "You are an expert backend systems engineer. Your task is to integrate Redis and BullMQ into the existing Node.js/TypeScript backend to enable asynchronous job processing for workflow executions. \n\n**Instructions:**\n1.  **Modify `docker-compose.yml`:** Add a new service for Redis using the official `redis:alpine` image. Ensure it's on the same network as the backend service.\n2.  **Update `backend/package.json`:** Add the `bullmq` and `ioredis` packages as dependencies.\n3.  **Create `backend/src/services/jobService.ts`:**\n    * Initialize a BullMQ `Queue` and `Worker` for a queue named 'workflow-execution'.\n    * The worker's processor function will be responsible for calling the existing `workflowExecutionService` logic to run a workflow. It should receive the `workflowId` and any initial user input as job data.\n    * The service should expose a method `addWorkflowToQueue(workflowId, userInput)` that adds a new job to the queue.\n4.  **Refactor `backend/src/api/controllers/workflowExecutionController.ts`:**\n    * Inject the new `JobService`.\n    * Modify the `executeWorkflow` function. Instead of calling the `workflowExecutionService` directly, it should now call `jobService.addWorkflowToQueue()`.\n    * It should immediately return a `202 Accepted` status with the newly created `jobId` and an initial status of 'pending'.\n5.  **Update Configuration:** Add `REDIS_HOST` and `REDIS_PORT` to `backend/.env.example` and update `backend/src/config/env.ts` to load these variables."
    },
    {
      "id": "ASYNC-02",
      "title": "Update Database Schema for Job Status Tracking",
      "epic": "Asynchronous Workflow Execution",
      "story": "As a database administrator, I want to modify the `workflow_executions` table to include status and result fields, so that the state of an asynchronous job can be tracked and its final output can be stored.",
      "acceptanceCriteria": [
        "A new SQL migration file is created in `database/migrations`.",
        "The `workflow_executions` table is altered to include a `status` column (e.g., VARCHAR, with possible values: 'pending', 'running', 'completed', 'failed').",
        "The `workflow_executions` table is altered to include a `result` column (e.g., JSONB) to store the final output.",
        "The `job_id` from BullMQ is stored in the `workflow_executions` table.",
        "The backend TypeScript types in `backend/src/types.ts` are updated to reflect the new schema."
      ],
      "system_prompt": "You are an expert database architect. Your task is to update the PostgreSQL schema to support tracking the status of asynchronous workflow executions. \n\n**Instructions:**\n1.  **Create a New Migration File:** Create a new file in `database/migrations`, named something like `004_add_status_to_executions.sql`.\n2.  **Write the SQL `ALTER TABLE` statement:**\n    * Add a `status` column to the `workflow_executions` table. It should be a `VARCHAR(255)` with a `DEFAULT` value of `'pending'`. Add a `CHECK` constraint to limit its values to 'pending', 'running', 'completed', 'failed'.\n    * Add a `result` column of type `JSONB` to store the final, structured output of the workflow.\n    * Add a `job_id` column of type `VARCHAR(255)` to store the unique identifier from the BullMQ job.\n3.  **Update Backend Types:** In `backend/src/types.ts`, find the `WorkflowExecution` interface and add the optional fields `status?: string;`, `result?: any;`, and `jobId?: string;`."
    },
    {
      "id": "ASYNC-03",
      "title": "Implement Real-Time Frontend Status Updates with WebSockets",
      "epic": "Asynchronous Workflow Execution",
      "story": "As a full-stack developer, I want to implement WebSockets for real-time communication between the frontend and backend, so that the user can see live updates on the status of their running workflow without needing to refresh the page.",
      "acceptanceCriteria": [
        "The `ws` package is added to the backend.",
        "A WebSocket server is initialized in the backend `app.ts`.",
        "The `JobService` is updated to emit events over WebSockets on job progress (e.g., 'task:start', 'task:complete', 'workflow:complete', 'workflow:failed').",
        "The frontend `useWorkflowRunner` hook is refactored to connect to the WebSocket server when a workflow is initiated.",
        "The frontend `TaskNode` component updates its visual state (e.g., shows a spinner, a checkmark, or an error icon) based on the events received from the WebSocket."
      ],
      "system_prompt": "You are an expert full-stack developer specializing in real-time applications. Your task is to implement a WebSocket layer for live progress updates on workflow executions.\n\n**Instructions:**\n1.  **Backend (`ws` package):\n    * In `backend/src/app.ts`, create and attach a WebSocket server to the main HTTP server.\n    * Create a `WebSocketService` that manages connected clients. It should have a method like `broadcast(message)`.\n    * In `backend/src/services/jobService.ts`, inject the `WebSocketService`. When the BullMQ worker processes a job, use the event listeners (`on('active')`, `on('completed')`, `on('failed')`) to call `webSocketService.broadcast()` with updates, including the `jobId`, `taskId`, and `status`.\n2.  **Frontend (`useWorkflowRunner.ts`):\n    * When the `runWorkflow` function is called, establish a new WebSocket connection to the backend.\n    * Set up an `onmessage` event listener. When a message is received, parse the JSON data.\n    * Update the local state of the workflow execution based on the event. For example, use a state management solution (like Zustand or React Context) to store the status of each task in the workflow.\n3.  **Frontend (`TaskNode.tsx`):\n    * The component should read the status for its corresponding task from the shared state.\n    * Conditionally render UI elements based on the status. For example, display a loading spinner if the status is 'running', a green checkmark if 'completed', and a red 'X' if 'failed'."
    },
    {
      "id": "DATA-01",
      "title": "Model and Implement Inter-Task Data Dependencies",
      "epic": "Explicit Data Flow and Dependency Management",
      "story": "As a full-stack developer, I want to define a data structure for task inputs and outputs and allow users to map them in the UI, so that I can create complex workflows where tasks consume the results of their predecessors.",
      "acceptanceCriteria": [
        "The `tasks` table in the database is updated to include an `inputs` JSONB column.",
        "The `WorkflowTask` type in `frontend/types.ts` and `backend/src/types.ts` is updated to include an `inputs` field.",
        "The `TaskNode` component in the frontend is updated to display input and output handles (using React Flow's `Handle` component).",
        "When a user connects two nodes, the `onConnect` callback in `WorkflowCanvas.tsx` updates the workflow state, storing the dependency in the `inputs` field of the target task.",
        "The updated workflow structure, including input mappings, is saved to the database."
      ],
      "system_prompt": "You are an expert full-stack application developer. Your task is to implement the core logic for data dependency management between tasks in a workflow.\n\n**Instructions:**\n1.  **Database Migration:** Create a new migration to add an `inputs` column of type `JSONB` to the `tasks` table. This will store the input mappings, e.g., `{\"summary_text\": {\"nodeId\": \"node_1\", \"outputName\": \"summary\"}}`.\n2.  **Type Updates:** Update the `WorkflowTask` type in both frontend and backend to include `inputs: Record<string, { nodeId: string; outputName: string; }>;`.\n3.  **Frontend UI (`TaskNode.tsx`):\n    * Using the `react-flow` library, add `<Handle type=\"source\" ... />` components for each defined output of a task.\n    * Add `<Handle type=\"target\" ... />` components for each defined input of a task.\n    * Position them appropriately on the node.\n4.  **Frontend Logic (`WorkflowCanvas.tsx`):\n    * Implement the `onConnect` prop for the `ReactFlow` component.\n    * When a connection is made, identify the source node, source handle (output), target node, and target handle (input).\n    * Update the state of the target node to reflect this new dependency in its `inputs` object.\n5.  **Backend API:** Ensure the `PUT /api/workflows/:id` endpoint correctly accepts and persists the new `tasks` structure, including the `inputs` field, to the database."
    },
    {
      "id": "DATA-02",
      "title": "Implement Backend Logic for Prompt Interpolation",
      "epic": "Explicit Data Flow and Dependency Management",
      "story": "As a backend developer, I want the `workflowExecutionService` to resolve task dependencies and interpolate the outputs from parent tasks into the prompts of child tasks before execution, so that data can flow through the workflow.",
      "acceptanceCriteria": [
        "A topological sort algorithm is implemented or used to determine the correct execution order of tasks in a workflow.",
        "The `workflowExecutionService` maintains a results map to store the output of each completed task.",
        "Before executing a task, the service checks its `inputs` field.",
        "The service retrieves the required outputs from the results map and uses them to replace placeholders in the task's prompt text (e.g., replacing `{{summary_text}}` with the actual summary).",
        "The task is executed with the fully interpolated prompt."
      ],
      "system_prompt": "You are an expert backend algorithm designer. Your task is to implement the dependency resolution and prompt interpolation logic within the workflow execution engine.\n\n**Instructions:**\n1.  **Execution Order:** In `backend/src/services/workflowExecutionService.ts`, before starting execution, perform a topological sort on the workflow's tasks based on their edge connections. This will give you a linear execution order that respects all dependencies. You can use a library like `ts-graph-structure` or implement a Kahn's algorithm.\n2.  **State Management:** During execution, maintain an in-memory map or dictionary, let's call it `executionState`, to store the results of each task as it completes (e.g., `executionState['node_1'] = { summary: 'This is a summary.' }`).\n3.  **Interpolation Logic:**\n    * For each task in the sorted execution order, iterate through its `inputs` object.\n    * For each input (e.g., `summary_text`), look up the corresponding `nodeId` and `outputName` in the `executionState` map to get the required value.\n    * Use a template literal replacement function (e.g., using regex or a simple string replace) to inject these values into the task's prompt template.\n    * Execute the LLM call with the final, interpolated prompt.\n4.  **Error Handling:** If a dependency cannot be resolved from the `executionState` map, the task should fail with a clear error message, and the workflow execution should be marked as 'failed'."
    },
    {
      "id": "SFL-01",
      "title": "Enhance Prompt Wizard with Structured Inputs",
      "epic": "Structured SFL Prompt Wizard",
      "story": "As a UX designer, I want to replace the free-text inputs for Tenor and Mode in the Prompt Wizard with structured controls like dropdowns and presets, so that users are better guided in creating effective, SFL-principled prompts.",
      "acceptanceCriteria": [
        "The `PromptWizardModal.tsx` component is refactored.",
        "The free-text input for 'Tenor' is replaced with a set of dropdowns: 'Formality' (Formal, Informal), 'Audience' (Expert, Novice), 'Stance' (Objective, Persuasive).",
        "The free-text input for 'Mode' is replaced with a dropdown of common text formats (e.g., 'Email', 'Report', 'Abstract', 'Code Comment').",
        "Selecting a 'Mode' preset populates a textarea with a boilerplate structure for that format.",
        "The final prompt is constructed by combining the structured inputs with the user's content for the 'Field'."
      ],
      "system_prompt": "You are an expert frontend developer with a keen eye for user experience. Your task is to refactor the `PromptWizardModal` to be more structured and user-friendly, based on SFL principles.\n\n**Instructions:**\n1.  **Component Refactoring (`frontend/components/PromptWizardModal.tsx`):\n    * Manage the state for each structured input (Field, Formality, Audience, Stance, Mode) using a `useState` hook or a reducer.\n2.  **Implement Tenor Controls:**\n    * Create three `<select>` dropdown components for Formality, Audience, and Stance, each populated with the predefined options.\n3.  **Implement Mode Controls:**\n    * Create a `<select>` dropdown for Mode with options like 'Email', 'Report', etc.\n    * Create a constants file or object that maps each Mode to a template string (e.g., `EMAIL_TEMPLATE = 'Subject: \\n\\nDear [Recipient],\\n\\n[Body]\\n\\nSincerely,\\n[Sender]'`).\n    * When a user selects a Mode, use a `useEffect` hook to update the main prompt textarea with the corresponding template.\n4.  **Prompt Assembly:**\n    * Create a function `assemblePrompt()` that constructs the final prompt text. This function should combine the user's 'Field' content with instructions derived from the 'Tenor' selections (e.g., 'Write in a formal tone for an expert audience.') and fit it into the 'Mode' template. The final assembled prompt should be displayed to the user in a read-only preview box before they save."
    },
    {
      "id": "HRM-01",
      "title": "Develop an AI Orchestrator for Automated Workflow Generation",
      "epic": "AI-Driven Hierarchical Reasoning",
      "story": "As a user, I want to provide a single complex prompt and have the system automatically generate and visualize a multi-step workflow to solve it, so that I can leverage hierarchical reasoning without designing the workflow manually.",
      "acceptanceCriteria": [
        "A new 'Orchestrator' prompt is designed, specifically tuned for task decomposition and workflow generation.",
        "The orchestrator prompt instructs the LLM to output a JSON object that conforms to the application's workflow data structure.",
        "A new API endpoint (e.g., `POST /api/orchestrate`) is created to handle these requests.",
        "The endpoint calls the LLM with the orchestrator prompt and the user's complex query.",
        "The returned JSON is validated and then used to populate the workflow state on the frontend, displaying the generated graph to the user.",
        "The user can then inspect, modify, and execute the AI-generated workflow."
      ],
      "system_prompt": "You are an expert AI systems architect specializing in agentic workflows. Your task is to design and implement an AI-powered orchestrator that can automatically generate workflows from a high-level user request.\n\n**Instructions:**\n1.  **Orchestrator Prompt Design:**\n    * Craft a detailed system prompt for a powerful LLM (e.g., Claude 3 Opus or GPT-4). This prompt is the 'meta-prompt' for the orchestrator.\n    * It must instruct the model to act as an expert project manager that decomposes a user's request into a series of logical, dependent tasks.\n    * Crucially, it must specify that the output MUST be a JSON object matching the exact structure of your `Workflow` type, including nodes (tasks) and edges (dependencies).\n    * Provide few-shot examples within the prompt to guide the model's output format.\n2.  **Backend API (`POST /api/orchestrate`):\n    * Create a new controller and service for this functionality.\n    * The service will take the user's complex prompt, combine it with your orchestrator system prompt, and make a call to the LLM service.\n    * It must include robust error handling and validation to ensure the LLM's output is a valid JSON that conforms to your workflow schema. If validation fails, it should retry or return a helpful error.\n3.  **Frontend Integration:\n    * Add a new 'Magic' or 'Orchestrate' button to the UI.\n    * When clicked, it takes the user's input and sends it to the new `/api/orchestrate` endpoint.\n    * On receiving a valid workflow JSON in response, use the `react-flow` instance's methods to clear the existing canvas and programmatically add the nodes and edges from the response, rendering the AI-generated plan for the user."
    }
  ]
}
